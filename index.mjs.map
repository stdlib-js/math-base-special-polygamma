{"version":3,"file":"index.mjs","sources":["../lib/atinfinityplus.js","../lib/attransitionplus.js","../lib/polycotpi.js","../lib/polyval_p3.js","../lib/polyval_p4.js","../lib/polyval_p5.js","../lib/polyval_p6.js","../lib/polyval_p7.js","../lib/polyval_p8.js","../lib/polyval_p9.js","../lib/polyval_p10.js","../lib/polyval_p11.js","../lib/polyval_p12.js","../lib/nearzero.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_65_0/boost/math/special_functions/detail/polygamma.hpp}. The implementation follows the original but has been modified for JavaScript.\n*\n* ```text\n* (C) Copyright Nikhar Agrawal 2013.\n* (C) Copyright Christopher Kormanyos 2013.\n* (C) Copyright John Maddock 2014.\n* (C) Copyright Paul Bristow 2013.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport bernoulli from '@stdlib/math-base-special-bernoulli';\nimport factorial from '@stdlib/math-base-special-factorial';\nimport gammaln from '@stdlib/math-base-special-gammaln';\nimport abs from '@stdlib/math-base-special-abs';\nimport exp from '@stdlib/math-base-special-exp';\nimport pow from '@stdlib/math-base-special-pow';\nimport ln from '@stdlib/math-base-special-ln';\nimport MAX_LN from '@stdlib/constants-float64-max-ln';\nimport LN_TWO from '@stdlib/constants-float64-ln-two';\nimport EPS from '@stdlib/constants-float64-eps';\n\n\n// VARIABLES //\n\nvar debug = logger( 'polygamma' );\nvar MAX_SERIES_ITERATIONS = 1000000;\nvar MAX_FACTORIAL = 172;\n\n\n// MAIN //\n\n/**\n* Evaluates the polygamma function for large values of `x` such as for `x > 400`.\n*\n* @private\n* @param {PositiveInteger} n - derivative to evaluate\n* @param {number} x - input\n* @returns {number} (n+1)'th derivative\n* @see {@link http://functions.wolfram.com/GammaBetaErf/PolyGamma2/06/02/0001/}\n*/\nfunction atinfinityplus( n, x ) {\n\tvar partTerm; // Value of current term excluding the Bernoulli number part\n\tvar xsquared;\n\tvar term; // Value of current term to be added to sum\n\tvar sum; // Current value of accumulated sum\n\tvar nlx;\n\tvar k2;\n\tvar k;\n\n\tif ( n+x === x ) {\n\t\t// If `x` is very large, just concentrate on the first part of the expression and use logs:\n\t\tif ( n === 1 ) {\n\t\t\treturn 1.0 / x;\n\t\t}\n\t\tnlx = n * ln( x );\n\t\tif ( nlx < MAX_LN && n < MAX_FACTORIAL ) {\n\t\t\treturn ( (n & 1) ? 1.0 : -1.0 ) * factorial( n-1 ) * pow( x, -n );\n\t\t}\n\t\treturn ( (n & 1) ? 1.0 : -1.0 ) * exp( gammaln( n ) - ( n*ln(x) ) );\n\t}\n\txsquared = x * x;\n\n\t// Start by setting `partTerm` to `(n-1)! / x^(n+1)`, which is common to both the first term of the series (with k = 1) and to the leading part. We can then get to the leading term by: `partTerm * (n + 2 * x) / 2` and to the first term in the series (excluding the Bernoulli number) by: `partTerm n * (n + 1) / (2x)`. If either the factorial would over- or the power term underflow, set `partTerm` to 0 and then we know that we have to use logs for the initial terms:\n\tif ( n > MAX_FACTORIAL && n*n > MAX_LN ) {\n\t\tpartTerm = 0.0;\n\t} else {\n\t\tpartTerm = factorial( n-1 ) * pow( x, -n-1 );\n\t}\n\tif ( partTerm === 0.0 ) {\n\t\t// Either `n` is very large, or the power term underflows. Set the initial values of `partTerm`, `term`, and `sum` via logs:\n\t\tpartTerm = gammaln(n) - ( (n+1) * ln(x) );\n\t\tsum = exp( partTerm + ln( n + (2.0*x) ) - LN_TWO );\n\t\tpartTerm += ln( n*(n+1) ) - LN_TWO - ln(x);\n\t\tpartTerm = exp( partTerm );\n\t} else {\n\t\tsum = partTerm * ( n+(2.0*x) ) / 2.0;\n\t\tpartTerm *= ( n*(n+1) ) / 2.0;\n\t\tpartTerm /= x;\n\t}\n\t// If the leading term is 0, so is the result:\n\tif ( sum === 0.0 ) {\n\t\treturn sum;\n\t}\n\tfor ( k = 1; ; ) {\n\t\tterm = partTerm * bernoulli( k*2 );\n\t\tsum += term;\n\n\t\t// Normal termination condition:\n\t\tif ( abs( term/sum ) < EPS ) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Increment our counter, and move `partTerm` on to the next value:\n\t\tk += 1;\n\t\tk2 = 2 * k;\n\t\tpartTerm *= ( n+k2-2 ) * ( n-1+k2 );\n\t\tpartTerm /= ( k2-1 ) * k2;\n\t\tpartTerm /= xsquared;\n\t\tif ( k > MAX_SERIES_ITERATIONS ) {\n\t\t\tdebug( 'Series did not converge, closest value was: %d.', sum );\n\t\t\treturn NaN;\n\t\t}\n\t}\n\tif ( ( n-1 ) & 1 ) {\n\t\tsum = -sum;\n\t}\n\treturn sum;\n}\n\n\n// EXPORTS //\n\nexport default atinfinityplus;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_65_0/boost/math/special_functions/detail/polygamma.hpp}. The implementation follows the original but has been modified for JavaScript.\n*\n* ```text\n* (C) Copyright Nikhar Agrawal 2013.\n* (C) Copyright Christopher Kormanyos 2013.\n* (C) Copyright John Maddock 2014.\n* (C) Copyright Paul Bristow 2013.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport factorial from '@stdlib/math-base-special-factorial';\nimport gammaln from '@stdlib/math-base-special-gammaln';\nimport trunc from '@stdlib/math-base-special-trunc';\nimport exp from '@stdlib/math-base-special-exp';\nimport pow from '@stdlib/math-base-special-pow';\nimport ln from '@stdlib/math-base-special-ln';\nimport MAX_LN from '@stdlib/constants-float64-max-ln';\nimport atinfinityplus from './atinfinityplus.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'polygamma' );\nvar MAX_SERIES_ITERATIONS = 1000000;\nvar DIGITS_BASE10 = 19;\n\n\n// MAIN //\n\n/**\n* Evaluates the polygamma function.\n*\n* @private\n* @param {PositiveInteger} n - derivative to evaluate\n* @param {number} x - input\n* @returns {number} (n+1)'th derivative\n* @see {@link http://functions.wolfram.com/GammaBetaErf/PolyGamma2/16/01/01/0017/}\n*/\nfunction attransitionplus( n, x ) {\n\tvar minusMminus1;\n\tvar lnterm;\n\tvar zpows;\n\tvar iter;\n\tvar sum0;\n\tvar d4d;\n\tvar N;\n\tvar m;\n\tvar k;\n\tvar z;\n\n\t// Use N = (0.4 * digits) + (4 * n) for target value for x:\n\td4d = 0.4 * DIGITS_BASE10;\n\tN = d4d + ( 4*n );\n\tm = n;\n\titer = N - trunc( x );\n\n\tif ( iter > MAX_SERIES_ITERATIONS ) {\n\t\tdebug( 'Exceeded maximum series evaluations when evaluated at n = %d and x = %d', n, x );\n\t\treturn NaN;\n\t}\n\tminusMminus1 = -m - 1;\n\tz = x;\n\tsum0 = 0.0;\n\tzpows = 0.0;\n\n\t// Forward recursion to larger `x`, need to check for overflow first though:\n\tif ( ln( z+iter ) * minusMminus1 > -MAX_LN ) {\n\t\tfor ( k = 1; k <= iter; k++ ) {\n\t\t\tzpows = pow( z, minusMminus1 );\n\t\t\tsum0 += zpows;\n\t\t\tz += 1;\n\t\t}\n\t\tsum0 *= factorial( n );\n\t} else {\n\t\tfor ( k = 1; k <= iter; k++ ) {\n\t\t\tlnterm = ( ln( z ) * minusMminus1 ) + gammaln( n+1 );\n\t\t\tsum0 += exp( lnterm );\n\t\t\tz += 1;\n\t\t}\n\t}\n\tif ( ( n-1 ) & 1 ) {\n\t\tsum0 = -sum0;\n\t}\n\treturn sum0 + atinfinityplus( n, z );\n}\n\n\n// EXPORTS //\n\nexport default attransitionplus;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_65_0/boost/math/special_functions/detail/polygamma.hpp}. The implementation follows the original but has been modified for JavaScript.\n*\n* ```text\n* (C) Copyright Nikhar Agrawal 2013.\n* (C) Copyright Christopher Kormanyos 2013.\n* (C) Copyright John Maddock 2014.\n* (C) Copyright Paul Bristow 2013.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport evalpoly from '@stdlib/math-base-tools-evalpoly';\nimport gammaln from '@stdlib/math-base-special-gammaln';\nimport signum from '@stdlib/math-base-special-signum';\nimport cospi from '@stdlib/math-base-special-cospi';\nimport sinpi from '@stdlib/math-base-special-sinpi';\nimport abs from '@stdlib/math-base-special-abs';\nimport exp from '@stdlib/math-base-special-exp';\nimport pow from '@stdlib/math-base-special-pow';\nimport ln from '@stdlib/math-base-special-ln';\nimport MAX_LN from '@stdlib/constants-float64-max-ln';\nimport PINF from '@stdlib/constants-float64-pinf';\nimport NINF from '@stdlib/constants-float64-ninf';\nimport LN_PI from '@stdlib/constants-float64-ln-pi';\nimport PI from '@stdlib/constants-float64-pi';\nimport zeros from '@stdlib/array-base-zeros';\nimport polyval3 from './polyval_p3.js';\nimport polyval4 from './polyval_p4.js';\nimport polyval5 from './polyval_p5.js';\nimport polyval6 from './polyval_p6.js';\nimport polyval7 from './polyval_p7.js';\nimport polyval8 from './polyval_p8.js';\nimport polyval9 from './polyval_p9.js';\nimport polyval10 from './polyval_p10.js';\nimport polyval11 from './polyval_p11.js';\nimport polyval12 from './polyval_p12.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'polygamma' );\nvar MAX_SERIES_ITERATIONS = 1000000;\n\n// π raised to powers two to twelve (obtained from Wolfram Alpha):\nvar PI2 = 9.869604401089358;\nvar PI3 = 31.00627668029982;\nvar PI4 = 97.40909103400244;\nvar PI5 = 306.01968478528147;\nvar PI6 = 961.3891935753045;\nvar PI7 = 3020.2932277767923;\nvar PI8 = 9488.531016070574;\nvar PI9 = 29809.09933344621;\nvar PI10 = 93648.04747608303;\nvar PI11 = 294204.0179738906;\nvar PI12 = 924269.1815233742;\n\n// Derivative memoization table:\nvar table = [\n\t[ -1.0 ]\n];\n\n\n// FUNCTIONS //\n\n/**\n* Updates the derivatives table.\n*\n* @private\n* @param {PositiveInteger} n - derivative\n*/\nfunction calculateDerivatives( n ) {\n\tvar noffset; // offset for next row\n\tvar offset; // 1 if the first cos power is 0; otherwise 0\n\tvar ncols; // how many entries there are in the current row\n\tvar mcols; // how many entries there will be in the next row\n\tvar mo; // largest order of the polynomial of cos terms\n\tvar so; // order of the sin term\n\tvar co; // order of the cosine term in entry \"j\"\n\tvar i;\n\tvar j;\n\tvar k;\n\n\tfor ( i = table.length-1; i < n-1; i++ ) {\n\t\toffset = ( i&1 )|0;\n\t\tso = ( i+2 )|0;\n\t\tmo = ( so-1 )|0;\n\t\tncols = ( (mo-offset)/2 )|0;\n\t\tnoffset = ( offset ) ? 0 : 1;\n\t\tmcols = ( (mo+1-noffset)/2 )|0;\n\t\ttable.push( zeros( mcols+1 ) );\n\t\tfor ( j = 0; j <= ncols; j++ ) {\n\t\t\tco = ( (2*j)+offset )|0;\n\t\t\tk = ( (co+1)/2 )|0;\n\t\t\ttable[ i+1 ][ k ] += ((co-so)*table[i][j]) / (so-1);\n\t\t\tif ( co ) {\n\t\t\t\tk = ( (co-1)/2 )|0;\n\t\t\t\ttable[ i+1 ][ k ] += (-co*table[i][j]) / (so-1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// MAIN //\n\n/**\n* Returns n'th derivative of \\\\(\\operatorname{cot|(\\pi x)\\\\) at \\\\(x\\\\).\n*\n* ## Notes\n*\n* -   The derivatives are simply tabulated for up to \\\\(n = 9\\\\), beyond that it is possible to calculate coefficients as follows. The general form of each derivative is:\n*\n*     ```tex\n*     \\pi^n * \\sum_{k=0}^n C[k,n] \\cdot \\cos^k(\\pi \\cdot x) \\cdot \\operatorname{csc}^{(n+1)}(\\pi \\cdot x)\n*     ```\n*\n*     with constant \\\\( C\\[0,1\\] = -1 \\\\) and all other \\\\( C\\[k,n\\] = 0 \\)). Then for each \\\\( k < n+1 \\\\):\n*\n*     ```tex\n*     \\begin{align*}\n*     C[k-1, n+1]  &-= k * C[k, n]; \\\\\n*     C[k+1, n+1]  &+= (k-n-1) * C[k, n];\n*     \\end{align*}\n*     ```\n*\n* -   Note that there are many different ways of representing this derivative thanks to the many trigonometric identities available. In particular, the sum of powers of cosines could be replaced by a sum of cosine multiple angles, and, indeed, if you plug the derivative into Mathematica, this is the form it will give. The two forms are related via the Chebeshev polynomials of the first kind and \\\\( T_n(\\cos(x)) = \\cos(n x) \\\\). The polynomial form has the great advantage that all the cosine terms are zero at half integer arguments - right where this function has it's minimum - thus avoiding cancellation error in this region.\n*\n* -   And finally, since every other term in the polynomials is zero, we can save space by only storing the non-zero terms. This greatly increases complexity when subscripting the tables in the calculation, but halves the storage space (and complexity for that matter).\n*\n* @private\n* @param {PositiveInteger} n - derivative to evaluate\n* @param {number} x - input\n* @param {number} xc - one minus `x`\n* @returns {number} n'th derivative\n*/\nfunction polycotpi( n, x, xc ) {\n\tvar powTerms;\n\tvar idx;\n\tvar out;\n\tvar sum;\n\tvar c;\n\tvar s;\n\n\ts = ( abs( x ) < abs( xc ) ) ? sinpi( x ) : sinpi( xc );\n\tc = cospi( x );\n\tswitch ( n ) { // eslint-disable-line default-case\n\tcase 1:\n\t\treturn -PI / ( s * s );\n\tcase 2:\n\t\treturn 2.0 * PI2 * c / pow( s, 3.0 );\n\tcase 3:\n\t\treturn PI3 * polyval3( c*c ) / pow( s, 4.0 );\n\tcase 4:\n\t\treturn PI4 * c * polyval4( c*c ) / pow( s, 5.0 );\n\tcase 5:\n\t\treturn PI5 * polyval5( c*c ) / pow( s, 6.0 );\n\tcase 6:\n\t\treturn PI6 * c * polyval6( c*c ) / pow( s, 7.0 );\n\tcase 7:\n\t\treturn PI7 * polyval7( c*c ) / pow( s, 8.0 );\n\tcase 8:\n\t\treturn PI8 * c * polyval8( c*c ) / pow( s, 9.0 );\n\tcase 9:\n\t\treturn PI9 * polyval9( c*c ) / pow( s, 10.0 );\n\tcase 10:\n\t\treturn PI10 * c * polyval10( c*c ) / pow( s, 11.0 );\n\tcase 11:\n\t\treturn PI11 * polyval11( c*c ) / pow( s, 12.0 );\n\tcase 12:\n\t\treturn PI12 * c * polyval12( c*c ) / pow( s, 13.0 );\n\t}\n\t// We'll have to compute the coefficients up to `n`, complexity is O(n^2) which we don't worry about as the values are computed once and then cached. However, if the final evaluation would have too many terms just bail out right away:\n\tif ( n/2 > MAX_SERIES_ITERATIONS ) {\n\t\tdebug( 'The value of `n` is so large that we\\'re unable to compute the result in reasonable time.' );\n\t\treturn NaN;\n\t}\n\tidx = n - 1;\n\tif ( idx >= table.length ) {\n\t\t// Lazily calculate derivatives:\n\t\tcalculateDerivatives( n );\n\t}\n\tsum = evalpoly( table[ idx ], c*c );\n\tif ( idx & 1 ) {\n\t\tsum *= c; // First coefficient is order 1, and really an odd polynomial.\n\t}\n\tif ( sum === 0.0 ) {\n\t\treturn sum;\n\t}\n\t// The remaining terms are computed using logs since the powers and factorials get real large real quick:\n\tpowTerms = n * LN_PI;\n\tif ( s === 0.0 ) {\n\t\treturn ( sum >= 0.0 ) ? PINF : NINF;\n\t}\n\tpowTerms -= ln( abs( s ) ) * ( n+1 );\n\tpowTerms += gammaln( n ) + ln( abs(sum) );\n\n\tif ( powTerms > MAX_LN ) {\n\t\treturn ( sum >= 0.0 ) ? PINF : NINF;\n\t}\n\tout = exp( powTerms ) * signum( sum );\n\tif ( s < 0.0 && ( (n+1)&1 ) ) {\n\t\tout *= -1;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default polycotpi;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn -2.0;\n\t}\n\treturn -2.0 + (x * -4.0);\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 16.0;\n\t}\n\treturn 16.0 + (x * 8.0);\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn -16.0;\n\t}\n\treturn -16.0 + (x * (-88.0 + (x * -16.0)));\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 272.0;\n\t}\n\treturn 272.0 + (x * (416.0 + (x * 32.0)));\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn -272.0;\n\t}\n\treturn -272.0 + (x * (-2880.0 + (x * (-1824.0 + (x * -64.0)))));\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 7936.0;\n\t}\n\treturn 7936.0 + (x * (24576.0 + (x * (7680.0 + (x * 128.0)))));\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn -7936.0;\n\t}\n\treturn -7936.0 + (x * (-137216.0 + (x * (-185856.0 + (x * (-31616.0 + (x * -256.0))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 353792.0;\n\t}\n\treturn 353792.0 + (x * (1841152.0 + (x * (1304832.0 + (x * (128512.0 + (x * 512.0))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn -353792.0;\n\t}\n\treturn -353792.0 + (x * (-9061376.0 + (x * (-21253376.0 + (x * (-8728576.0 + (x * (-518656.0 + (x * -1024.0))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* This is a generated file. Do not edit directly. */\n'use strict';\n\n// MAIN //\n\n/**\n* Evaluates a polynomial.\n*\n* ## Notes\n*\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @private\n* @param {number} x - value at which to evaluate the polynomial\n* @returns {number} evaluated polynomial\n*/\nfunction evalpoly( x ) {\n\tif ( x === 0.0 ) {\n\t\treturn 22368256.0;\n\t}\n\treturn 22368256.0 + (x * (175627264.0 + (x * (222398464.0 + (x * (56520704.0 + (x * (2084864.0 + (x * 2048.0))))))))); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default evalpoly;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_65_0/boost/math/special_functions/detail/polygamma.hpp}. The implementation follows the original but has been modified for JavaScript.\n*\n* ```text\n* (C) Copyright Nikhar Agrawal 2013.\n* (C) Copyright Christopher Kormanyos 2013.\n* (C) Copyright John Maddock 2014.\n* (C) Copyright Paul Bristow 2013.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport factorial from '@stdlib/math-base-special-factorial';\nimport zeta from '@stdlib/math-base-special-riemann-zeta';\nimport abs from '@stdlib/math-base-special-abs';\nimport pow from '@stdlib/math-base-special-pow';\nimport NINF from '@stdlib/constants-float64-ninf';\nimport PINF from '@stdlib/constants-float64-pinf';\nimport EPS from '@stdlib/constants-float64-eps';\nimport MAX from '@stdlib/constants-float64-max';\n\n\n// VARIABLES //\n\nvar debug = logger( 'polygamma' );\nvar MAX_SERIES_ITERATIONS = 1000000;\n\n\n// MAIN //\n\n/**\n* Evaluates the polygamma function near zero.\n*\n* ## Notes\n*\n* -   If we take this [expansion][1] for `polygamma` and substitute in this [expression][2] for `polygamma(n, 1)`, we get an alternating series for polygamma when `x` is small in terms of zeta functions of integer arguments (which are easy to evaluate, at least when the integer is even).\n*\n* [1]: http://functions.wolfram.com/06.15.06.0003.02\n* [2]: http://functions.wolfram.com/06.15.03.0009.01\n*\n* @private\n* @param {PositiveInteger} n - derivative to evaluate\n* @param {number} x - input value\n* @returns {number} (n+1)'th derivative\n*/\nfunction nearzero( n, x ) {\n\tvar factorialPart;\n\tvar prefix;\n\tvar scale;\n\tvar term;\n\tvar sum;\n\tvar AX;\n\tvar k;\n\n\t// In order to avoid spurious overflow, save the `n!` term for later, and rescale at the end:\n\tscale = factorial( n );\n\n\t// \"factorialPart\" contains everything except the zeta function evaluations in each term:\n\tfactorialPart = 1;\n\n\t// \"prefix\" is what we'll be adding the accumulated sum to, it will be `n! / z^(n+1)`, but since we're scaling by `n!` it is just `1 / z^(n+1)` for now:\n\tprefix = pow( x, n+1 );\n\tif ( prefix === 0.0 ) {\n\t\treturn PINF;\n\t}\n\tprefix = 1.0 / prefix;\n\n\t// First term in the series is necessarily `< zeta(2) < 2`, so ignore the sum if it will have no effect on the result:\n\tif ( prefix > 2.0/EPS ) {\n\t\tif ( n & 1 ) {\n\t\t\treturn ( AX/prefix < scale ) ? PINF : prefix * scale;\n\t\t}\n\t\treturn ( AX/prefix < scale ) ? NINF : -prefix * scale;\n\t}\n\tsum = prefix;\n\tfor ( k = 0; ; ) {\n\t\t// Get the k'th term:\n\t\tterm = factorialPart * zeta( k+n+1 );\n\t\tsum += term;\n\n\t\t// Termination condition:\n\t\tif ( abs( term ) < abs(sum * EPS ) ) {\n\t\t\tbreak;\n\t\t}\n\t\t// Move on `k` and `factorialPart`:\n\t\tk += 1;\n\t\tfactorialPart *= (-x * (n+k)) / k;\n\n\t\t// Last chance exit:\n\t\tif ( k > MAX_SERIES_ITERATIONS ) {\n\t\t\tdebug( 'Series did not converge, best value is %d.', sum );\n\t\t\treturn NaN;\n\t\t}\n\t}\n\t// We need to multiply by the scale, at each stage checking for overflow:\n\tif ( MAX/scale < sum ) {\n\t\treturn PINF;\n\t}\n\tsum *= scale;\n\treturn ( n & 1 ) ? sum : -sum;\n}\n\n\n// EXPORTS //\n\nexport default nearzero;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_65_0/boost/math/special_functions/detail/polygamma.hpp}. The implementation follows the original but has been modified for JavaScript.\n*\n* ```text\n* (C) Copyright Nikhar Agrawal 2013.\n* (C) Copyright Christopher Kormanyos 2013.\n* (C) Copyright John Maddock 2014.\n* (C) Copyright Paul Bristow 2013.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nvar logger = require( 'debug' );\nimport isNonNegativeInteger from '@stdlib/math-base-assert-is-nonnegative-integer';\nimport factorial from '@stdlib/math-base-special-factorial';\nimport trigamma from '@stdlib/math-base-special-trigamma';\nimport digamma from '@stdlib/math-base-special-digamma';\nimport signum from '@stdlib/math-base-special-signum';\nimport ldexp from '@stdlib/math-base-special-ldexp';\nimport floor from '@stdlib/math-base-special-floor';\nimport trunc from '@stdlib/math-base-special-trunc';\nimport zeta from '@stdlib/math-base-special-riemann-zeta';\nimport abs from '@stdlib/math-base-special-abs';\nimport min from '@stdlib/math-base-special-min';\nimport PINF from '@stdlib/constants-float64-pinf';\nimport NINF from '@stdlib/constants-float64-ninf';\nimport MAX from '@stdlib/constants-float64-max';\nimport PI from '@stdlib/constants-float64-pi';\nimport attransitionplus from './attransitionplus.js';\nimport atinfinityplus from './atinfinityplus.js';\nimport polycotpi from './polycotpi.js';\nimport nearzero from './nearzero.js';\n\n\n// VARIABLES //\n\nvar debug = logger( 'polygamma' );\nvar DIGITS_BASE10 = 19;\n\n\n// MAIN //\n\n/**\n* Evaluates the polygamma function.\n*\n* @param {NonNegativeInteger} n - order of derivative\n* @param {number} x - input value\n* @returns {number} (n+1)'th derivative\n*\n* @example\n* var v = polygamma( 3, 1.2 );\n* // returns ~3.245\n*\n* @example\n* var v = polygamma( 5, 1.2 );\n* // returns ~41.39\n*\n* @example\n* var v = polygamma( 3, -4.9 );\n* // returns ~60014.239\n*\n* @example\n* var v = polygamma( 2.5, -1.2 );\n* // returns NaN\n*\n* @example\n* var v = polygamma( -1, 5.3 );\n* // returns NaN\n*\n* @example\n* var v = polygamma( 2, -2.0 );\n* // returns NaN\n*\n* @example\n* var v = polygamma( NaN, 2.1 );\n* // returns NaN\n*\n* @example\n* var v = polygamma( 1, NaN );\n* // returns NaN\n*\n* @example\n* var v = polygamma( NaN, NaN );\n* // returns NaN\n*/\nfunction polygamma( n, x ) {\n\tvar xSmallLimit;\n\tvar result;\n\tvar z;\n\n\tif ( !isNonNegativeInteger( n ) ) {\n\t\treturn NaN;\n\t}\n\tif ( n === 0 ) {\n\t\treturn digamma( x );\n\t}\n\tif ( n === 1 ) {\n\t\treturn trigamma( x );\n\t}\n\tif ( x < 0.0 ) {\n\t\tif ( floor(x) === x ) {\n\t\t\t// Result is infinity if `x` is odd, and a pole error if `x` is even.\n\t\t\tif ( trunc( x ) & 1 ) {\n\t\t\t\treturn PINF;\n\t\t\t}\n\t\t\tdebug( 'Evaluation at negative integer: %d.', x );\n\t\t\treturn NaN;\n\t\t}\n\t\tz = 1.0 - x;\n\t\tresult = polygamma( n, z ) + ( PI * polycotpi( n, z, x ) );\n\t\treturn ( n & 1 ) ? -result : result;\n\t}\n\t// Limit for use of small-x series is chosen so that the series doesn't go too divergent in the first few terms. Ordinarily, this would mean setting the limit to `~1/n`, but we can tolerate a small amount of divergence:\n\txSmallLimit = min( 5.0/n, 0.25 );\n\tif ( x < xSmallLimit ) {\n\t\treturn nearzero( n, x );\n\t}\n\tif ( x > ( 0.4 * DIGITS_BASE10 ) + ( 4*n ) ) {\n\t\treturn atinfinityplus( n, x );\n\t}\n\tif ( x === 1.0 ) {\n\t\treturn ( ( n & 1 ) ? 1.0 : -1.0 ) * factorial( n ) * zeta( n+1 );\n\t}\n\tif ( x === 0.5 ) {\n\t\tresult = ( ( n & 1 ) ? 1.0 : -1.0 ) * factorial( n ) * zeta( n+1 );\n\t\tif ( abs( result ) >= ldexp( MAX, -n-1 ) ) {\n\t\t\treturn ( signum( result ) === 1 ) ? PINF : NINF;\n\t\t}\n\t\tresult *= ldexp( 1.0, n+1 ) - 1.0;\n\t\treturn result;\n\t}\n\treturn attransitionplus( n, x );\n}\n\n\n// EXPORTS //\n\nexport default polygamma;\n"],"names":["debug","require$$0","atinfinityplus","n","x","partTerm","xsquared","term","sum","k2","k","ln","MAX_LN","factorial","pow","exp","gammaln","LN_TWO","bernoulli","abs","EPS","NaN","table","polycotpi","xc","powTerms","idx","out","c","s","sinpi","cospi","PI","polyval3","polyval4","polyval5","polyval6","polyval7","polyval8","polyval9","polyval10","polyval11","polyval12","length","offset","ncols","mcols","mo","so","co","i","j","push","zeros","calculateDerivatives","evalpoly","LN_PI","PINF","NINF","signum","polygamma","result","z","isNonNegativeInteger","digamma","trigamma","floor","trunc","min","factorialPart","prefix","scale","AX","zeta","MAX","nearzero","ldexp","minusMminus1","lnterm","iter","sum0","m","attransitionplus"],"mappings":"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"}